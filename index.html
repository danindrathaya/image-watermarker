<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Watermarker</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Custom font */
      body {
        font-family: "Inter", sans-serif;
      }
      /* Ensure canvas is responsive but doesn't overflow */
      canvas {
        max-width: 100%;
        height: auto;
        display: none; /* Hide until image is loaded */
      }
    </style>
  </head>
  <body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-xl w-full max-w-lg">
      <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-800 mb-6">
        Image Watermarker
      </h1>

      <!-- Form Inputs -->
      <div class="space-y-4">
        <div>
          <label
            for="imageLoader"
            class="block text-sm font-medium text-gray-700 mb-1"
          >
            Upload Image
          </label>
          <input
            type="file"
            id="imageLoader"
            accept="image/*"
            class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors"
          />
        </div>

        <!-- NEW: Watermark controls container, hidden by default -->
        <div id="watermarkControls" class="space-y-4 hidden">
          <div>
            <label
              for="watermarkText"
              class="block text-sm font-medium text-gray-700 mb-1"
            >
              Watermark Text
            </label>
            <input
              type="text"
              id="watermarkText"
              placeholder="Watermark Text - "
              class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              value=""
            />
          </div>

          <!-- Position Inputs -->
          <div class="flex flex-col sm:flex-row gap-4">
            <div class="w-full sm:w-1/2">
              <label
                for="posX"
                class="block text-sm font-medium text-gray-700 mb-1"
              >
                X Position
              </label>
              <input
                type="number"
                id="posX"
                value="0"
                step="1"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
              <!-- NEW: X Slider --><input
                type="range"
                id="posXSlider"
                step="5"
                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2"
              />
            </div>
            <div class="w-full sm:w-1/2">
              <label
                for="posY"
                class="block text-sm font-medium text-gray-700 mb-1"
              >
                Y Position
              </label>
              <input
                type="number"
                id="posY"
                value="0"
                step="1"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
              <!-- NEW: Y Slider --><input
                type="range"
                id="posYSlider"
                step="5"
                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2"
              />
            </div>
          </div>

          <!-- Style Inputs -->
          <div class="flex flex-col sm:flex-row gap-4">
            <div class="w-full sm:w-1/2">
              <label
                for="fontSize"
                class="block text-sm font-medium text-gray-700 mb-1"
              >
                Font Size (px)
              </label>
              <input
                type="number"
                id="fontSize"
                value="20"
                step="1"
                min="12"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            <div class="w-full sm:w-1/2 flex gap-4">
              <div class="w-1/2">
                <label
                  for="color"
                  class="block text-sm font-medium text-gray-700 mb-1"
                >
                  Text Color
                </label>
                <input
                  type="color"
                  id="color"
                  value="#FFFFFF"
                  class="w-full h-10 px-1 py-1 border border-gray-300 rounded-lg shadow-sm cursor-pointer"
                />
              </div>
              <!-- NEW: Background Color Input -->
              <div class="w-1/2">
                <label
                  for="bgColor"
                  class="block text-sm font-medium text-gray-700 mb-1"
                >
                  BG Color
                </label>
                <input
                  type="color"
                  id="bgColor"
                  value="#000000"
                  class="w-full h-10 px-1 py-1 border border-gray-300 rounded-lg shadow-sm cursor-pointer"
                />
              </div>
            </div>
          </div>

          <div>
            <label
              for="opacity"
              class="block text-sm font-medium text-gray-700 mb-1"
            >
              Opacity (<span id="opacityValue">0.5</span>)
            </label>
            <input
              type="range"
              id="opacity"
              min="0"
              max="1"
              value="0.5"
              step="0.05"
              class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
          </div>
        </div>
      </div>

      <!-- Canvas for processing -->
      <div class="mt-6 border-t border-gray-200 pt-6">
        <h2 class="text-lg font-semibold text-gray-700 mb-4 text-center">
          Preview
        </h2>
        <div
          id="canvasContainer"
          class="bg-gray-50 p-4 rounded-lg border border-gray-200 flex justify-center items-center min-h-[200px] relative"
        >
          <canvas id="imageCanvas" class="rounded-md shadow-inner"></canvas>
          <p
            id="placeholderText"
            class="text-gray-400 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
          >
            Your image will appear here
          </p>
        </div>
      </div>

      <!-- Download Link -->
      <div class="mt-4 text-center">
        <a
          id="downloadLink"
          class="inline-block bg-green-600 text-white font-bold py-2.5 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition-all transform hover:scale-[1.02] hidden"
        >
          Download Image
        </a>
      </div>
    </div>

    <script>
      const imageLoader = document.getElementById("imageLoader");
      const watermarkControls = document.getElementById("watermarkControls");
      const watermarkText = document.getElementById("watermarkText");
      const posX = document.getElementById("posX");
      const posY = document.getElementById("posY");
      const posXSlider = document.getElementById("posXSlider");
      const posYSlider = document.getElementById("posYSlider");
      const fontSize = document.getElementById("fontSize");
      const color = document.getElementById("color");
      const bgColor = document.getElementById("bgColor");
      const opacity = document.getElementById("opacity");
      const opacityValue = document.getElementById("opacityValue");
      const canvas = document.getElementById("imageCanvas");
      const ctx = canvas.getContext("2d");
      const downloadLink = document.getElementById("downloadLink");
      const placeholderText = document.getElementById("placeholderText");

      let originalImage = null;
      let originalFilename = "";

      // Function to get formatted date
      function getCurrentDate() {
        const now = new Date();
        const day = String(now.getDate()).padStart(2, "0");
        const month = String(now.getMonth() + 1).padStart(2, "0");
        const year = now.getFullYear();
        return `${day}/${month}/${year}`;
      }

      // Set initial placeholder with current date
      watermarkText.placeholder = `Watermark Text - ${getCurrentDate()}`;

      opacity.addEventListener("input", (e) => {
        opacityValue.textContent = parseFloat(e.target.value).toFixed(2);
      });

      imageLoader.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) {
          return;
        }
        originalFilename = file.name.split(".").slice(0, -1).join(".");

        const reader = new FileReader();

        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            originalImage = img;

            // Set canvas to original image dimensions
            canvas.width = img.width;
            canvas.height = img.height;

            // Draw at original size first
            ctx.drawImage(img, 0, 0);

            // If the image is large, create a compressed version
            if (img.width > 1500 || img.height > 1500) {
              // Create a temporary canvas for compression
              const tempCanvas = document.createElement("canvas");
              const tempCtx = tempCanvas.getContext("2d");

              // Calculate scale factor to get a reasonable size for processing
              const scaleFactor = Math.min(
                1,
                Math.min(1500 / img.width, 1500 / img.height)
              );
              tempCanvas.width = img.width * scaleFactor;
              tempCanvas.height = img.height * scaleFactor;

              // Draw scaled version
              tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

              // Clear main canvas
              ctx.clearRect(0, 0, canvas.width, canvas.height);

              // Draw back to main canvas at original size with compression
              ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);

              // Clean up
              tempCanvas.remove();
            }
            posX.value = Math.floor(canvas.width / 2);
            posY.value = Math.floor(canvas.height / 2); // Still canvas-relative for input, then inverted

            // Show default watermark preview
            watermarkText.value = watermarkText.placeholder;
            drawWatermark();

            posXSlider.min = 0;
            posXSlider.max = canvas.width;
            posXSlider.value = posX.value;

            posYSlider.min = 0;
            posYSlider.max = canvas.height;
            posYSlider.value = posY.value;

            let defaultFontSize = Math.floor(canvas.width * 0.03);
            fontSize.value = Math.max(defaultFontSize, 20);

            color.value = "#FFFFFF";
            bgColor.value = "#000000";
            opacity.value = 0.5;
            opacityValue.textContent = "0.5";

            canvas.style.display = "block";
            placeholderText.style.display = "none";

            watermarkControls.classList.remove("hidden");

            downloadLink.classList.add("hidden");
            downloadLink.href = "#";
          };
          img.src = event.target.result;
        };

        reader.readAsDataURL(file);
      });

      // Helper to convert hex to rgba
      function hexToRgba(hex, alpha) {
        let r = 0,
          g = 0,
          b = 0;
        if (hex.length === 7) {
          // e.g., #FFFFFF
          r = parseInt(hex.substring(1, 3), 16);
          g = parseInt(hex.substring(3, 5), 16);
          b = parseInt(hex.substring(5, 7), 16);
        }
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function drawWatermark() {
        if (!originalImage) {
          return;
        }

        ctx.drawImage(originalImage, 0, 0);

        const text = watermarkText.value;

        if (text) {
          const size = parseInt(fontSize.value, 10) || 20;
          const textColor = color.value || "#FFFFFF";
          const backgroundColor = bgColor.value || "#000000"; // NEW
          const opacityValueNum = parseFloat(opacity.value) || 0.5;

          ctx.font = `bold ${size}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const x = parseInt(posX.value, 10) || 0;
          const yInput = parseInt(posY.value, 10) || 0;
          const canvasY = canvas.height - yInput; // Invert Y for visualization

          // NEW: Draw background rectangle
          const textMetrics = ctx.measureText(text);
          const textWidth = textMetrics.width;
          // A bit of padding for the background
          const paddingX = size * 0.4;
          const paddingY = size * 0.2;
          const rectWidth = textWidth + paddingX * 2;
          const rectHeight = size + paddingY * 2; // Using font size as a baseline for height

          // Calculate top-left corner of the background rectangle
          // Since text is centered, we need to offset by half its width/height
          const rectX = x - rectWidth / 2;
          const rectY = canvasY - rectHeight / 2;

          ctx.fillStyle = hexToRgba(backgroundColor, opacityValueNum); // Apply background color with opacity
          ctx.fillRect(rectX, rectY, rectWidth, rectHeight);

          // Draw the text
          ctx.fillStyle = hexToRgba(textColor, opacityValueNum); // Apply text color with opacity
          ctx.fillText(text, x, canvasY);
        }

        downloadLink.href = canvas.toDataURL("image/png");
        downloadLink.download = text
          ? `${originalFilename}-watermarked.png`
          : `${originalFilename}-unchanged.png`;
        downloadLink.classList.remove("hidden");
      }

      // Debounce function to limit how often the watermark is redrawn
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      const debouncedDrawWatermark = debounce(drawWatermark, 50);

      const allControls = [
        watermarkText,
        posX,
        posY,
        fontSize,
        color,
        bgColor,
        opacity,
      ];

      allControls.forEach((control) => {
        control.addEventListener("input", debouncedDrawWatermark);
      });

      posXSlider.addEventListener("input", () => {
        posX.value = posXSlider.value;
        posX.dispatchEvent(new Event("input"));
      });

      posYSlider.addEventListener("input", () => {
        posY.value = posYSlider.value;
        posY.dispatchEvent(new Event("input"));
      });

      posX.addEventListener("input", () => {
        posXSlider.value = posX.value;
      });

      posY.addEventListener("input", () => {
        posYSlider.value = posY.value;
      });
    </script>
  </body>
</html>
